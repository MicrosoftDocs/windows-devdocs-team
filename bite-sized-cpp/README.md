# Bite-sized C++

Take one bite per day for a shallow on-ramp to ISO Standard C++, C++/WinRT, and programming with C++ and the [Windows App SDK](https://docs.microsoft.com/windows/apps/windows-app-sdk/).

Brought to you by the Windows Developer Documentation team.

[#1. Why C++?](./posts/001.md) | [为什么是C++？](./posts/cn/001.md)

[#2. Header files (.h files)](./posts/002.md)

[#3. Data members, and member functions](./posts/003.md)

[#4. Dots and arrows](./posts/004.md)

[#5. Dots and double colons](./posts/005.md)

[#6. Including a header file (Part 1)](./posts/006.md)

[#7. Including a header file (Part 2)](./posts/007.md)

[#8. Including a header file (Part 3)](./posts/008.md)

[#9. Linking, and the linker](./posts/009.md)

[#10. Linker errors](./posts/010.md)

[#11. Why not choose Rust over C++?](./posts/011.md)

[#12. Why not accept the dot operator everywhere?](./posts/012.md)

[#13. Classes and structures are *almost* the same thing in C++ (Part 1)](./posts/013.md)

[#14. Classes and structures are *almost* the same thing in C++ (Part 2)](./posts/014.md)

[#15. Access specifiers (public and private)](./posts/015.md)

[#16. Access specifiers (protected)](./posts/016.md)

[#17. Declarations of member functions](./posts/017.md)

[#18. Definitions of member functions](./posts/018.md)

[#19. Definitions of data members and classes/structs](./posts/019.md)

[#20. Class/struct declarations](./posts/020.md)

[#21. Error handling (Part 1)](./posts/021.md)

[#22. Error handling (Part 2)](./posts/022.md)

[#23. Throwing and catching exceptions (Part 1)](./posts/023.md)

[#24. Throwing and catching exceptions (Part 2)](./posts/024.md)

[#25. Throwing and catching exceptions (Part 3)](./posts/025.md)

[#26. Best practices with exceptions (Part 1)](./posts/026.md)

[#27. Best practices with exceptions (Part 2)](./posts/027.md)

[#28. Best practices with exceptions (Part 3)](./posts/028.md)

[#29. Why doesn't C++ have a `finally` construct? (Part 1)](./posts/029.md)

[#30. Why doesn't C++ have a `finally` construct? (Part 2)](./posts/030.md)

[#31. Why doesn't C++ have a `finally` construct? (Part 3)](./posts/031.md)

[#32. Automatic variables (Part 1)](./posts/032.md)

[#33. Automatic variables (Part 2)](./posts/033.md)

[#34. Automatic variables (Part 3)](./posts/034.md)

[#35. Why doesn't C++ have a `finally` construct? (Part 4)](./posts/035.md)

[#36. Why doesn't C++ have a `finally` construct? (Part 5)](./posts/036.md)

[#37. Pop quiz!](./posts/037.md)

[#38. Writing a string to output (Part 1)](./posts/038.md)

[#39. Writing a string to output (Part 2)](./posts/039.md)

[#40. C++ containers](./posts/040.md)

[#41. C++ iterators](./posts/041.md)

[#42. C++ iterators with `do-while` and `while`](./posts/042.md)

[#43. The for-loop](./posts/043.md)

[#44. Range-based `for` (Part 1)](./posts/044.md)

[#45. Range-based `for` (Part 2)](./posts/045.md)

[#46. Range-based `for` (Part 3)](./posts/046.md)

[#47. Uniform initialization (Part 1)](./posts/047.md)

[#48. Uniform initialization (Part 2)](./posts/048.md)

[#49. More formatted output using streams (Part 1)](./posts/049.md)

[#50. More formatted output using streams (Part 2)](./posts/050.md)

[#51. The **std::for_each** algorithm (Part 1)](./posts/051.md)

[#52. Procedure and policy (Part 1)](./posts/052.md)

[#53. Procedure and policy (Part 2)](./posts/053.md)

[#54. The **std::for_each** algorithm (Part 2)](./posts/054.md)

[#55. Zero-initializing a struct](./posts/055.md)

[#56. Initializing a struct to *any* value](./posts/056.md)

[#57. Default member initializers](./posts/057.md)

[#58. Initializer lists (Part 1)](./posts/058.md)

[#59. Initializer lists (Part 2)](./posts/059.md)

[#60. Value types in C++](./posts/060.md)

[#61. Reference types in C++](./posts/061.md)

[#62. Accessing via a reference](./posts/062.md)

[#63. Modifying via a reference](./posts/063.md)

[#64. Functions that take values (Part 1)](./posts/064.md)

[#65. Functions that take values (Part 2)](./posts/065.md)

[#66. Functions that take values (Part 3)](./posts/066.md)

[#67. Functions that take references (Part 1)](./posts/067.md)

[#68. Functions that take references (Part 2)](./posts/068.md)

[#69. Passing large values around](./posts/069.md)

[#70. Passing by constant reference](./posts/070.md)

[#71. Naming conventions (snake_case)](./posts/071.md)

[#72. Naming conventions (PascalCase and camelCase)](./posts/072.md)

[#73. Naming conventions (private data members)](./posts/073.md)

[#74. Second pop quiz!](./posts/074.md)

[#75. Returning a value](./posts/075.md)

[#76. Returning a reference](./posts/076.md)

[#77. Returning a reference to a local variable](./posts/077.md)

[#78. What it means to *seat* a reference](./posts/078.md)

[#79. Why you can't re-seat a reference (Part 1)](./posts/079.md)

[#80. Why you can't re-seat a reference (Part 2)](./posts/080.md)

[#81. Assign using references](./posts/081.md)

[#82. Identity (Part 1)](./posts/082.md)

[#83. Identity (Part 2)](./posts/083.md)

[#84. Identity (Part 3)](./posts/084.md)

[#85 Overloading the equality operator](./posts/085.md)

[#86 The `this` pointer (Part 1)](./posts/086.md)

[#87 The `this` pointer (Part 2)](./posts/087.md)

[#88 The `this` pointer (Part 3)](./posts/088.md)

[#89 Overloading the inequality operator](./posts/089.md)
