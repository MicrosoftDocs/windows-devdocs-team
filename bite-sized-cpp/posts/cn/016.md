# #16. 访问说明符（protected）

`public`访问说明符使成员可以从其类/结构之外访问。对于成员函数，这意味着它是可调用的。对于数据成员来说，这意味着它是可读写的。

不过，这对数据成员来说相当危险，因为它破坏了封装。最好将数据成员保持私有或受保护，并提供一个公共成员函数来访问（即，*返回*）该数据成员的值。您还可以选择添加一个成员函数，该函数*变异*（更改）数据成员的值。然后，您基本上创建了一个属性，您可以选择以一个简单的数据成员（本质上是一个字段）无法实现的方式在输出和/或输入时验证/转换值。

但*protected*是什么意思？

我们知道，`private`意味着*只能从拥有该成员的类/结构中访问*。`protected`访问说明符扩展了这一点，允许从*从所属类/结构*直接或间接派生的任何类/结构*中访问成员。

对了，你*可以*从一个类中派生一个结构。反之亦然。类和结构是相同的（除了默认的访问控制）。

举几个例子说明什么时候可以使用`protected`？假设你正在写[Direct3D 12](https://docs.microsoft.com/windows/win32/direct3d12/directx-12-programming-guide)渲染器，并且您有一个不同类型的3D网格的类/结构层次。在该层次结构的基类/结构中，可能有一个[ID3D12Resource](https://docs.microsoft.com/windows/win32/api/d3d12/nn-d3d12-id3d12resource)表示网格顶点数据的数据成员。但你也需要能够从基类型中*派生*的类型中访问该成员（定义特定派生类型的网格，并将其上传到GPU）。因此，只需将数据成员设为`protected`，派生类型也可以访问它。

或者，对于成员函数示例，类似地，您可能有一个表示3D场景的类型层次结构。层次结构中的不同场景类型需要不同的像素着色器，因此您可能有一个`protected`成员函数，该函数返回一个字符串，表示适当编译的着色器对象的名称（这样一些通用代码就可以按名称加载该对象）。每个派生类型都会提供其自己的`protected`成员函数的实现，以返回其使用的特定像素着色器的名称。在本例中，成员函数也是虚拟的，这样基类就可以自己调用函数，并获得正确的实现。C++`protected`和`virtual`关键字的工作方式与它们在C#中的工作方式类似，但我们以后可能会再次讨论它们。

然而，C++既没有`protected internal`，也没有`private protected`。

|前一个|后一个|内容|
|-|-|-|
|[#15. 访问说明符（公共和私有）](015.md)|[#17. 成员函数声明](017.md)]|[Bite-sized C++](../../README.md)|
