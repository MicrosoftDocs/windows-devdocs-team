# #6. 包括头文件（第1部分）

还记得[#2.头文件（.h文件）](002.md)中的**MyClass**的C++版本吗？我们说过（通常）你在头中描述函数，但你把它们的实现放在实现文件中。为什么要这么麻烦地把事情分开？

假设你是一个拥有数学函数库的软件供应商，，其中包含了你的专有算法（这是你昂贵的研发成果，来之不易）。您已经在一个名为**MathLibClass**的类中实现了这些函数。传统上，您会向客户提供头文件、静态链接库和[`.dll`](https://docs.microsoft.com/windows/win32/dlls/dynamic-link-libraries).头文件描述了函数，因此您的客户知道每个函数的名称、返回的内容以及使用的参数。在他们的项目中，您的客户链接静态链接库，这样构建过程就可以从这些函数名转换为`.dll`中的入口点。而你的客户会打包`.dll`到其应用程序，因为其中包含函数的实现&amp;mdash；但只能以机器可读（而不是人类可读）的形式。您已经为客户提供了SDK，但您的知识产权（IP）完好无损。

不过，在C#中，任何人都可以相对容易地在您发布的程序集中查看您的源代码（IP），除非您使用工具混淆（obfuscate）了它。

现在让我们假设我是一个购买C++数学函数SDK（包含**MathLibClass**）的客户。如何在项目中使用头？像下面这样：

```cpp
#include <MathLibClass.h>
```

`include`前面的*散列符号*（#）告诉我们它是预处理器的指令（其他示例包括`#define`和`#ifdef`，仅举两个例子）。一旦您指示预处理器用指定的C++头的内容替换include，那么该头中描述的所有函数都将进入作用域，以便您可以调用它们。但是你把它放在哪个文件里呢？我们下次再讨论选择。

|前一个|后一个|内容|
|-|-|-|
|[#5. 点和双冒号](005.md)|[#7. 包括头文件（第2部分）](007.md)|[Bite-sized C++](../../README.md)|
